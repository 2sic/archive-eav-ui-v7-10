{
  "name": "ng-annotate",
  "version": "1.0.2",
  "description": "add, remove and rebuild angularjs dependency injection annotations",
  "main": "build/es5/ng-annotate-main.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/olov/ng-annotate.git"
  },
  "dependencies": {
    "acorn": "~2.1.0",
    "alter": "~0.2.0",
    "convert-source-map": "~1.0.0",
    "optimist": "~0.6.1",
    "ordered-ast-traverse": "~1.1.1",
    "simple-fmt": "~0.1.0",
    "simple-is": "~0.2.0",
    "source-map": "~0.4.2",
    "stable": "~0.1.5",
    "stringmap": "~0.2.2",
    "stringset": "~0.2.1",
    "tryor": "~0.1.2"
  },
  "devDependencies": {
    "coffee-script": "~1.9.1",
    "defs": "~1.1.0",
    "diff": "~1.3.1",
    "find-line-column": "~0.5.2"
  },
  "keywords": [
    "angular",
    "angularjs",
    "di",
    "dependency",
    "injection",
    "annotate",
    "annotation",
    "annotations",
    "transformation"
  ],
  "scripts": {
    "test": "node --harmony run-tests"
  },
  "bin": {
    "ng-annotate": "./build/es5/ng-annotate"
  },
  "author": {
    "name": "Olov Lassus",
    "email": "olov.lassus@gmail.com"
  },
  "license": "MIT",
  "readme": "# ng-annotate\nng-annotate adds and removes AngularJS dependency injection annotations.\nIt is non-intrusive so your source code stays exactly the same otherwise.\nNo lost comments or moved lines. Annotations are useful because with them\nyou're able to minify your source code using your favorite JS minifier.\n\nYou write your code without annotations, like this:\n\n```js\nangular.module(\"MyMod\").controller(\"MyCtrl\", function($scope, $timeout) {\n});\n```\n\nYou then run ng-annotate as a build-step to produce this intermediary,\nannotated, result (later sent to the minifier):\n\n```js\nangular.module(\"MyMod\").controller(\"MyCtrl\", [\"$scope\", \"$timeout\", function($scope, $timeout) {\n}]);\n```\n\nYou can also use ng-annotate to rebuild or remove existing annotations.\nRebuilding is useful if you like to check-in the annotated version of your\nsource code. When refactoring, just change parameter names once and let\nng-annotate rebuild the annotations. Removing is useful if you want to\nde-annotate an existing codebase that came with checked-in annotations\n\n**ng-annotate works by using static analysis to identify common code patterns.\nThere are patterns it does not and never will understand and for those you\ncan use an explicit `ngInject` annotation instead, see section further down.**\n\n\n## Installation and usage\n\n```bash\nnpm install -g ng-annotate\n```\n\nThen run it as `ng-annotate OPTIONS <file>`. The errors (if any) will go to stderr,\nthe transpiled output to stdout.\n\nUse the `--add` (`-a`) option to add annotations where non-existing,\nuse `--remove` (`-r`) to remove all existing annotations,\nuse `--add --remove` (`-ar`) to rebuild all annotations.\n\nUse the `-o` option to write output to file.\n\nProvide `-` instead of an input `<file>` to read input from stdin.\n\nUse the `--sourcemap` option to generate an inline sourcemap.\n\nUse the `--sourceroot` option to set the sourceRoot property of the generated sourcemap.\n\nUse the `--single_quotes` option to output `'$scope'` instead of `\"$scope\"`.\n\nUse the `--regexp` option to restrict matching further or to expand matching.\nSee description further down.\n\nUse the `--list` option to list optional matchers.\n\nUse the `--enable` option to enable optional matcher.\n\n*experimental* Use the `--rename` option to rename providers (services, factories,\ncontrollers, etc.) with a new name when declared and referenced through annotation.\nUse it like this: `--rename oldname1 newname1 oldname2 newname2`\n\n*experimental* Use the `--plugin` option to load a user plugin with the provided path,\n1.x may change API). See [plugin-example.js](plugin-example.js) for more info.\n\n*experimental* Use the `--stats` option to print statistics on stderr.\n\n\n## ES6 and TypeScript support\nng-annotate supports ES5 as input so run it with the output from Babel, Traceur,\nTypeScript (tsc) and the likes. Use `\"ngInject\";` on functions you want annotated.\nYour transpiler should preserve directive prologues, if not please file a bug on it.\n\n\n## Highly recommended: enable ng-strict-di in your minified builds\n`<div ng-app=\"myApp\" ng-strict-di>`\n\nDo that in your ng-annotate processed builds and AngularJS will let you know if there are\nany missing dependency injection annotations. [ng-strict-di](https://docs.angularjs.org/api/ng/directive/ngApp)\nis available in AngularJS 1.3 or later.\n\n\n## Tools support\n* [Grunt](http://gruntjs.com/): [grunt-ng-annotate](https://www.npmjs.org/package/grunt-ng-annotate) by [Michał Gołębiowski](https://github.com/mzgol)\n* [Browserify](http://browserify.org/): [browserify-ngannotate](https://www.npmjs.org/package/browserify-ngannotate) by [Owen Smith](https://github.com/omsmith)\n* [Brunch](http://brunch.io/): [ng-annotate-uglify-js-brunch](https://www.npmjs.org/package/ng-annotate-uglify-js-brunch) by [Kagami Hiiragi](https://github.com/Kagami)\n* [Gulp](http://gulpjs.com/): [gulp-ng-annotate](https://www.npmjs.org/package/gulp-ng-annotate/) by [Kagami Hiiragi](https://github.com/Kagami)\n* [Broccoli](https://github.com/broccolijs/broccoli): [broccoli-ng-annotate](https://www.npmjs.org/package/broccoli-ng-annotate) by [Gilad Peleg](https://github.com/pgilad)\n* [Rails asset pipeline](http://guides.rubyonrails.org/asset_pipeline.html): [ngannotate-rails](https://rubygems.org/gems/ngannotate-rails) by [Kari Ikonen](https://github.com/kikonen)\n* [Grails asset pipeline](https://github.com/bertramdev/asset-pipeline): [angular-annotate-asset-pipeline](https://github.com/craigburke/angular-annotate-asset-pipeline) by [Craig Burke](https://github.com/craigburke)\n* [Webpack](http://webpack.github.io/): [ng-annotate-webpack-plugin](https://www.npmjs.org/package/ng-annotate-webpack-plugin) by [Chris Liechty](https://github.com/cliechty)\n* [Middleman](http://middlemanapp.com/): [middleman-ngannotate](http://rubygems.org/gems/middleman-ngannotate) by [Michael Siebert](https://github.com/siebertm)\n* [ENB](http://enb-make.info/) (Russian): [enb-ng-techs](https://www.npmjs.org/package/enb-ng-techs#ng-annotate) by [Alexey Gurianov](https://github.com/guria)\n* Something missing? Contributions welcome - create plugin and submit a README pull request!\n\n\n## Changes\nSee [CHANGES.md](CHANGES.md).\n\n\n## Declaration forms\nng-annotate understands the two common declaration forms:\n\nLong form:\n\n```js\nangular.module(\"MyMod\").controller(\"MyCtrl\", function($scope, $timeout) {\n});\n```\n\nShort form:\n\n```js\nmyMod.controller(\"MyCtrl\", function($scope, $timeout) {\n});\n```\n\nIt's not limited to `.controller` of course. It understands `.config`, `.factory`,\n`.directive`, `.filter`, `.run`, `.controller`, `.provider`, `.service`, `.animation` and\n`.invoke`.\n\nFor short forms it does not need to see the declaration of `myMod` so you can run it\non your individual source files without concatenating. If ng-annotate detects a short form\nfalse positive then you can use the `--regexp` option to limit the module identifier.\nExamples: `--regexp \"^myMod$\"` (match only `myMod`) or `--regexp \"^$\"` (ignore short forms).\nYou can also use `--regexp` to opt-in for more advanced method callee matching, for\nexample `--regexp \"^require(.*)$\"` to detect and transform\n`require('app-module').controller(..)`. Not using the option is the same as passing\n`--regexp \"^[a-zA-Z0-9_\\$\\.\\s]+$\"`, which means that the callee can be a (non-unicode)\nidentifier (`foo`), possibly with dot notation (`foo.bar`).\n\nng-annotate understands `angular.module(\"MyMod\", function(dep) ..)` as an alternative to\n`angular.module(\"MyMod\").config(function(dep) ..)`.\n\nng-annotate understands `this.$get = function($scope) ..` and\n`{.., $get: function($scope) ..}` inside a `provider`. `self` and `that` can be used as\naliases for `this`.\n\nng-annotate understands `return {.., controller: function($scope) ..}` inside a\n`directive`.\n\nng-annotate understands `$provide.decorator(\"bar\", function($scope) ..)`, `$provide.service`,\n`$provide.factory` and `$provide.provider`.\n\nng-annotate understands `$routeProvider.when(\"path\", { .. })`.\n\nng-annotate understands `$httpProvider.interceptors.push(function($scope) ..)` and\n`$httpProvider.responseInterceptors.push(function($scope) ..)`.\n\nng-annotate understands `$injector.invoke(function ..)`.\n\nng-annotate understands [ui-router](https://github.com/angular-ui/ui-router) (`$stateProvider` and\n`$urlRouterProvider`).\n\nng-annotate understands `$modal.open` ([angular-ui/bootstrap](http://angular-ui.github.io/bootstrap/)).\n\nng-annotate understands `$mdDialog.show`, `$mdToast.show` and `$mdBottomSheet.show`\n([angular material design](https://material.angularjs.org/#/api/material.components.dialog/service/$mdDialog)).\n\nng-annotate understands `myMod.store(\"MyCtrl\", function ..)`\n([flux-angular](https://github.com/christianalfoni/flux-angular)).\n\nng-annotate understands chaining.\n\nng-annotate understands IIFE's and attempts to match through them, so\n`(function() { return function($scope) .. })()` works anywhere\n`function($scope) ..` does (for any IIFE args and params).\n\nng-annotate understands [angular-dashboard-framework](https://github.com/sdorra/angular-dashboard-framework)\nvia optional `--enable angular-dashboard-framework`.\n\n\n## Reference-following\nng-annotate follows references. This works iff the referenced declaration is\na) a function declaration or\nb) a variable declaration with an initializer.\nModifications to a reference outside of its declaration site are ignored by ng-annotate.\n\nThese examples will get annotated:\n\n```js\nfunction MyCtrl($scope, $timeout) {\n}\nvar MyCtrl2 = function($scope) {};\n\nangular.module(\"MyMod\").controller(\"MyCtrl\", MyCtrl);\nangular.module(\"MyMod\").controller(\"MyCtrl\", MyCtrl2);\n```\n\n\n## Explicit annotations with ngInject\nYou can prepend a function with `/*@ngInject*/` to explicitly state that the function\nshould get annotated. ng-annotate will leave the comment intact and will thus still\nbe able to also remove or rewrite such annotations.\n\nYou can also wrap an expression inside an `ngInject(..)` function call. If you use this\nsyntax then add `function ngInject(v) { return v }` somewhere in your codebase, or process\naway the `ngInject` function call in your build step.\n\nYou can also add the `\"ngInject\"` directive prologue at the beginning of a function,\nsimilar to how `\"use strict\"` is used, to state that the surrounding function should get\nannotated.\n\nUse `ngInject` to support your code style when it's not in a form ng-annotate understands\nnatively. Remember that the intention of ng-annotate is to reduce stuttering for you,\nand `ngInject` does this just as well. You don't need to keep two lists in sync. Use it!\n\n`ngInject` may be particularly useful if you use a compile-to-JS language that doesn't\npreserve comments.\n\n\n### Suppressing false positives with ngNoInject\nThe `/*@ngInject*/`, `ngInject(..)` and `\"ngInject\"` siblings have three cousins that\nare used for the opposite purpose, suppressing an annotation that ng-annotate added\nincorrectly (a \"false positive\"). They are called `/*@ngNoInject*/`, `ngNoInject(..)`\nand `\"ngNoInject\"` and do exactly what you think they do.\n\n\n### ngInject examples\nHere follows some ngInject examples using the `/*@ngInject*/` syntax. Most examples\nworks fine using the `ngInject(..)` or `\"ngInject\"` syntax as well.\n\n```js\nx = /*@ngInject*/ function($scope) {};\nobj = {controller: /*@ngInject*/ function($scope) {}};\nobj.bar = /*@ngInject*/ function($scope) {};\n\n=>\n\nx = /*@ngInject*/ [\"$scope\", function($scope) {}];\nobj = {controller: /*@ngInject*/ [\"$scope\", function($scope) {}]};\nobj.bar = /*@ngInject*/ [\"$scope\", function($scope) {}];\n```\n\nPrepended to an object literal, `/*@ngInject*/` will annotate all of its contained\nfunction expressions, recursively:\n\n```js\nobj = /*@ngInject*/ {\n    controller: function($scope) {},\n    resolve: { data: function(Service) {} },\n};\n\n=>\n\nobj = /*@ngInject*/ {\n    controller: [\"$scope\", function($scope) {}],\n    resolve: { data: [\"Service\", function(Service) {}] },\n};\n```\n\nPrepended to a function statement, to a single variable declaration initialized with a\nfunction expression or to an assignment where the rvalue is a function expression,\n `/*@ngInject*/` will attach an `$inject` array to the function:\n\n```js\n// @ngInject\nfunction Foo($scope) {}\n\n// @ngInject\nvar foo = function($scope) {}\n\n// @ngInject\nmodule.exports = function($scope) {}\n\n=>\n\n// @ngInject\nfunction Foo($scope) {}\nFoo.$inject = [\"$scope\"];\n\n// @ngInject\nvar foo = function($scope) {}\nfoo.$inject = [\"$scope\"];\n\n// @ngInject\nmodule.exports = function($scope) {}\nmodule.exports.$inject = [\"$scope\"];\n```\n\n\n## Build and test\nng-annotate is written in ES6 constlet style and uses [defs.js](https://github.com/olov/defs)\nto transpile to ES5. See [BUILD.md](BUILD.md) for build and test instructions.\n\n\n## License\n`MIT`, see [LICENSE](LICENSE) file.\n\nng-annotate is written by [Olov Lassus](https://github.com/olov) with the kind help by\n[contributors](https://github.com/olov/ng-annotate/graphs/contributors).\n[Follow @olov](https://twitter.com/olov) on Twitter for updates about ng-annotate.\n\n\n## How does ng-annotate compare to ngmin?\nngmin has been deprecated in favor of ng-annotate. In short:\nng-annotate is much faster, finds more declarations to annotate (including ui-router),\ntreats your source code better, is actively maintained and has a bunch of extra features\non top of that. A much more elaborated answer can be found in\n[\"The future of ngmin and ng-annotate\"](https://github.com/btford/ngmin/issues/93).\n\n*Migrating from ngmin*:\n`ng-annotate -a -` is similar to `ngmin` (use stdin and\nstdout). `ng-annotate -a in.js -o out.js` is similar to `ngmin in.js out.js`. Grunt users\ncan migrate easily by installing\n[grunt-ng-annotate](https://www.npmjs.org/package/grunt-ng-annotate) and replacing `ngmin`\nwith `ngAnnotate` in their Gruntfile. Scroll down for information about other tools.\n\n\n## Library (API)\nng-annotate can be used as a library. See [ng-annotate.js](ng-annotate.js) for further info about\noptions and return value.\n\n```js\nvar ngAnnotate = require(\"ng-annotate\");\nvar somePlugin = require(\"./some/path/some-plugin\");\nvar res = ngAnnotate(src, {\n    add: true,\n    plugin: [somePlugin],\n    rename: [{from: \"generalname\", to: \"uniquename\"}, {from: \"alpha\", to: \"beta\"}],\n    map: { inline: false, inFile: \"source.js\", sourceRoot: \"/path/to/source/root\" },\n    enable: [\"angular-dashboard-framework\"],\n});\nvar errorstringArray = res.errors;\nvar transformedSource = res.src;\nvar transformedSourceMap = res.map;\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/olov/ng-annotate/issues"
  },
  "homepage": "https://github.com/olov/ng-annotate",
  "_id": "ng-annotate@1.0.2",
  "_shasum": "5fd42b54bca89dd0d17a9e211c620a4e85e0f8f9",
  "_from": "ng-annotate@1.0.2",
  "_resolved": "https://registry.npmjs.org/ng-annotate/-/ng-annotate-1.0.2.tgz"
}
